{"ast":null,"code":"import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport axios from 'axios';\nconst initialState = {\n  repos: [],\n  selectedRepo: null,\n  sortField: null,\n  sortOrder: 'asc',\n  currentPage: 1,\n  pageSize: 10,\n  loading: false,\n  error: null\n};\nexport const fetchRepos = createAsyncThunk('repos/fetchRepos', async query => {\n  const response = await axios.get(`https://api.github.com/search/repositories?q=${query}`);\n  return response.data.items;\n});\nconst repoSlice = createSlice({\n  name: 'repos',\n  initialState,\n  reducers: {\n    setSelectedRepo(state, action) {\n      state.selectedRepo = action.payload;\n    },\n    setSortField(state, action) {\n      if (state.sortField === action.payload) {\n        state.sortOrder = state.sortOrder === 'asc' ? 'desc' : 'asc';\n      } else {\n        state.sortField = action.payload;\n        state.sortOrder = 'asc';\n      }\n    },\n    setSortOrder(state, action) {\n      state.sortOrder = action.payload;\n    },\n    setCurrentPage(state, action) {\n      state.currentPage = action.payload;\n    },\n    sortRepos(state) {\n      if (state.sortField) {\n        const startIndex = (state.currentPage - 1) * state.pageSize;\n        const endIndex = startIndex + state.pageSize;\n        const currentRepos = state.repos.slice(startIndex, endIndex);\n        currentRepos.sort((a, b) => {\n          const fieldA = a[state.sortField];\n          const fieldB = b[state.sortField];\n          if (typeof fieldA === 'number' && typeof fieldB === 'number') {\n            return state.sortOrder === 'asc' ? fieldA - fieldB : fieldB - fieldA;\n          } else if (typeof fieldA === 'string' && typeof fieldB === 'string') {\n            return state.sortOrder === 'asc' ? fieldA.localeCompare(fieldB) : fieldB.localeCompare(fieldA);\n          } else {\n            return 0;\n          }\n        });\n        state.repos.splice(startIndex, state.pageSize, ...currentRepos);\n      }\n    }\n  },\n  extraReducers: builder => {\n    builder.addCase(fetchRepos.pending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(fetchRepos.fulfilled, (state, action) => {\n      state.loading = false;\n      state.repos = action.payload;\n    }).addCase(fetchRepos.rejected, (state, action) => {\n      state.loading = false;\n      state.error = action.error.message || 'Failed to fetch repositories';\n    });\n  }\n});\nexport const {\n  setSelectedRepo,\n  setSortField,\n  setSortOrder,\n  setCurrentPage,\n  sortRepos\n} = repoSlice.actions;\nexport default repoSlice.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","axios","initialState","repos","selectedRepo","sortField","sortOrder","currentPage","pageSize","loading","error","fetchRepos","query","response","get","data","items","repoSlice","name","reducers","setSelectedRepo","state","action","payload","setSortField","setSortOrder","setCurrentPage","sortRepos","startIndex","endIndex","currentRepos","slice","sort","a","b","fieldA","fieldB","localeCompare","splice","extraReducers","builder","addCase","pending","fulfilled","rejected","message","actions","reducer"],"sources":["/Users/aleksandr/github-repo-search/src/redux/repoSlice.ts"],"sourcesContent":["import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';\nimport axios from 'axios';\n\nexport interface Repo {\n  id: number;\n  name: string;\n  language: string;\n  forks_count: number;\n  stargazers_count: number;\n  updated_at: string;\n  description: string;\n  license: {\n    name: string;\n  } | null;\n}\n\ninterface RepoState {\n  repos: Repo[];\n  selectedRepo: Repo | null;\n  sortField: keyof Repo | null;\n  sortOrder: 'asc' | 'desc';\n  currentPage: number;\n  pageSize: number;\n  loading: boolean;\n  error: string | null;\n}\n\nconst initialState: RepoState = {\n  repos: [],\n  selectedRepo: null,\n  sortField: null,\n  sortOrder: 'asc',\n  currentPage: 1,\n  pageSize: 10,\n  loading: false,\n  error: null,\n};\n\nexport const fetchRepos = createAsyncThunk(\n  'repos/fetchRepos',\n  async (query: string) => {\n    const response = await axios.get(`https://api.github.com/search/repositories?q=${query}`);\n    return response.data.items as Repo[];\n  }\n);\n\nconst repoSlice = createSlice({\n  name: 'repos',\n  initialState,\n  reducers: {\n    setSelectedRepo(state, action: PayloadAction<Repo>) {\n      state.selectedRepo = action.payload;\n    },\n    setSortField(state, action: PayloadAction<keyof Repo>) {\n      if (state.sortField === action.payload) {\n        state.sortOrder = state.sortOrder === 'asc' ? 'desc' : 'asc';\n      } else {\n        state.sortField = action.payload;\n        state.sortOrder = 'asc';\n      }\n    },\n    setSortOrder(state, action: PayloadAction<'asc' | 'desc'>) {\n      state.sortOrder = action.payload;\n    },\n    setCurrentPage(state, action: PayloadAction<number>) {\n      state.currentPage = action.payload;\n    },\n    sortRepos(state) {\n      if (state.sortField) {\n        const startIndex = (state.currentPage - 1) * state.pageSize;\n        const endIndex = startIndex + state.pageSize;\n        const currentRepos = state.repos.slice(startIndex, endIndex);\n\n        currentRepos.sort((a, b) => {\n          const fieldA = a[state.sortField!];\n          const fieldB = b[state.sortField!];\n\n          if (typeof fieldA === 'number' && typeof fieldB === 'number') {\n            return state.sortOrder === 'asc' ? fieldA - fieldB : fieldB - fieldA;\n          } else if (typeof fieldA === 'string' && typeof fieldB === 'string') {\n            return state.sortOrder === 'asc'\n              ? fieldA.localeCompare(fieldB)\n              : fieldB.localeCompare(fieldA);\n          } else {\n            return 0;\n          }\n        });\n\n        state.repos.splice(startIndex, state.pageSize, ...currentRepos);\n      }\n    },\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(fetchRepos.pending, (state) => {\n        state.loading = true;\n        state.error = null;\n      })\n      .addCase(fetchRepos.fulfilled, (state, action) => {\n        state.loading = false;\n        state.repos = action.payload;\n      })\n      .addCase(fetchRepos.rejected, (state, action) => {\n        state.loading = false;\n        state.error = action.error.message || 'Failed to fetch repositories';\n      });\n  },\n});\n\nexport const { setSelectedRepo, setSortField, setSortOrder, setCurrentPage, sortRepos } = repoSlice.actions;\n\nexport default repoSlice.reducer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}